module ActiveAdmin
  module Views

    # Renders an ActiveAdmin::Menu as a set of unordered list items.
    #
    # This component takes cares of deciding which items should be
    # displayed given the current context and renders them appropriately.
    #
    # The entire component is rendered within one ul element.
    class TabbedNavigation < Component

      attr_reader :menu

      # Build a new tabbed navigation component.
      #
      # @param [ActiveAdmin::Menu] menu the Menu to render
      # @param [Hash] options the options as passed to the underlying ul element.
      #
      def build(menu, options = {})
        @menu = menu
        super(default_options.merge(options))
        build_menu
      end

      # The top-level menu items that should be displayed.
      def menu_items
        menu.items(self)
      end

      def tag_name
        'ul'
      end

      private

      def default_class_name
        'nav'
      end

      def build_menu
        menu_items.each do |item|
          build_menu_item(item)
        end
      end

      def build_menu_item(item)
<<<<<<< HEAD
        dom_id = case item.dom_id
        when Proc,Symbol
          normalize_id call_method_or_proc_on(self, item.dom_id)
        else
          item.dom_id
        end

        li :id => dom_id do |li_element|
          li_element.add_class "active" if current?(item)

          if item.items.any?
            li_element.add_class "dropdown"

            actual_item_link item do |label, url|
              a :href => url, :class => "dropdown-toggle", :"data-toggle" => "dropdown" do
                text_node(label) +
                b(:class => :caret)
              end
            end

            render_nested_menu(item)
          else
            actual_item_link item
          end
        end
      end

      def normalize_id(string)
        string.to_s.downcase.gsub(" ", "_").gsub(/[^a-z0-9_]/, '')
      end

      def actual_item_link(item, &block)

        label = case item.label
        when Symbol
          send item.label
        when Proc
          item.label.call rescue instance_exec(&item.label)
        else
          item.label.to_s
        end

        link_path = url_for_menu_item(item)
        if block_given?
          yield(label, link_path)
        else
          link_to(label, link_path, item.html_options)
        end

      end
=======
        li :id => item.id do |li|
          li.add_class "current" if item.current? assigns[:current_tab]
>>>>>>> refs/heads/master

          text_node link_to item.label(self), item.url(self), item.html_options

<<<<<<< HEAD
      def render_nested_menu(item)
        ul :class => "dropdown-menu" do
          displayable_items(item.items).each do |child|
            build_menu_item child
=======
          if children = item.items(self).presence
            li.add_class "has_nested"
            ul do
              children.each{ |child| build_menu_item child }
            end
>>>>>>> refs/heads/master
          end
        end
      end

      def default_options
        { :id => "tabs" }
      end
    end
  end
end
